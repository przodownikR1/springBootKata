= SpringBoot camp
:docInfo1
:numbered:
:icons: font
:pagenums:
:imagesdir: images
:iconsdir: ./icons
:stylesdir: ./styles
:scriptsdir: ./js

:image-link: https://pbs.twimg.com/profile_images/425289501980639233/tUWf7KiC.jpeg
ifndef::sourcedir[:sourcedir: ./src/main/java/]
ifndef::resourcedir[:resourcedir: ./src/main/resources/]
ifndef::imgsdir[:imgsdir: ./../images]
:source-highlighter: coderay


== O mnie
* Architect Solution - RiscoSoftware 
* VavaTech trener : Spring ekosystem, JPA , EIP Camel 
* Sages trener : JPA , EIP - Apache Camel 
* blog link:http://przewidywalna-java.blogspot.com[]
* twitter przodownikR1

image:{image-link} [role='img-circle']


== Co to jest Spring Boot ?


== Cechy i cechy

** Błyskawiczne wytwarzanie

** Prototypowanie

** Eliminacja XML

** Autokonfiguracja

*** Prostota konfiguracji zależności

*** Prostota konfiguracji aplikacji

** Starters dependencies

** Command-line interface

** Wbudowany kontener Tomcat lub Jetty

** Zcentralizowana konfiguracja 

*** application.properties

*** application.yml

** Profile



** Monitoring

*** Actuator

** Microservices :)

source: https://www.nginx.com/blog/building-microservices-inter-process-communication/

image:Richardson-microservices-part1-1_monolithic-architecture.png[]

image:Richardson-microservices-part2-3_api-gateway.png[]

image:Richardson-microservices-part3-monolith-vs-microservices.png[]

image:Richardson-microservices-part3-taxi-service.png[]

image:mono-vs-mirco.png[]

Za : 

*** łatwość wytwarzania aplikacji typu  'stand-alone' gotowych na wdrożenie produkcyjne

*** szybka konfiguracja wykorzystująca model Convention over Configuration

*** możliwość wyrzucenia konfiguracji poza projekt

*** wczechobecny jar zamiast starego ear czy war 

*** szybki deploy

*** wielkie serwery aplikacyjne

*** monolit - utrzymywanie i rozwijanie

*** splątane zależności

*** małe autonomiczne usługi

*** małe autonomiczne zespoły

*** łatwość zrozumienia domeny

*** łatwa skalowalność

*** izolacja sytuacji krytycznych

*** dobór odpowiednich narzędzi i języków do danej domeny

***   

Przeciw : 

*** testowanie

*** debugowanie

*** próg wejścia

*** nowe wzorce architektoniczne

*** zwiększona pamięciożerność


NOTE : Aktualna wersja 1.4.0.RELEASE wymaga Java 7 i Spring Framework 4.3.2.RELEASE lub wyżej


== Narzędzia

=== http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.4.0.RELEASE/spring-boot-cli-1.4.0.RELEASE-bin.zip[Spring Boot CLI]

----
spring init -dweb,data-jpa,h2,thymeleaf --build gradle mySimpleApp --force
----

=== STS

=== IDEA

=== https://start.spring.io/[Initializr]

==== Poprzez 

interfejs web
Spring Tool Suite
IDEA


Spring Boot CLIbuild.gradle—A Gradle build specification. Had you chosen a Maven project,
this would be replaced with pom.xml.
Application.java—A class with a main() method to bootstrap the application.
ApplicationTests.java—An empty JU nit test class instrumented to load a Spring
application context using Spring Boot auto-configuration.
application.properties—An empty properties file for you to add configuration
properties to as you see fit.

** 


== Spring Boot 1.4 features

=== Banner

=== Error page

== Strona projektu 

http://projects.spring.io/spring-boot/[spring boot]

== Dokumentacja 

http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/[dokumentacja]


== Spring vs Spring Boot

=== Podejście standardowe

** Projekt webowy musi zawierać folder WEB-INF

*** opjonalny plik : web.xml

*** <servlet-name>-servlet.xml


=== Aplikacja WEB/REST


** Stworzenie pliku web.xml lub WebApplicationInitializer, żeby zadeklarować DispatcherServlet

**  Skonfigurowanie Spring MVC

** Stworzenie prostego kontrolera i zarejestrowanie go

** Odpalenie aplikacji na jakimś kontenerze servletów lub serwerze aplikacyjnym



** Prosty kontroller 


[source,java]
----
@Controller
@EnableAutoConfiguration
public class SampleController {

    @RequestMapping("/")
    @ResponseBody
    String home() {
        return "Hello World!";
    }

    public static void main(String[] args) throws Exception { //configuration & bootstrapping
        SpringApplication.run(SampleController.class, args);
    }
}
----


[source,java]
----
@RestController
public class SimpleWebController {
@RequestMapping("/")
public String greetings(){
return "Hello world";
}
}
----


=== Pierwsza prosta aplikacja


== Uruchamianie 

=== Maven

** Konfiguracja 

[source,xml]
----

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

<modelVersion>4.0.0</modelVersion>
<groupId>com.example</groupId>
<artifactId>myapp</artifactId>
<version>0.0.1-SNAPSHOT</version>

<parent>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.3.6.RELEASE</version>
</parent>

<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        ...
</dependencies>

<build>
<plugins>
  <plugin>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-maven-plugin</artifactId>
   </plugin>
</plugins>
</build>
</project>
----

== Creating an executable jar

----
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
----
 
== Maven

Dziedziczenie z 'parenta'

----
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.4.0.RELEASE</version>
</parent>
----

----
<properties>
    <spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>
</properties>
----

===  Spring Boot bez udziału parent POM

----
<dependencyManagement>
     <dependencies>
        <dependency>
            <!-- Import dependency management from Spring Boot -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>1.4.0.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
----

----

<dependencyManagement>
    <dependencies>     
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-releasetrain</artifactId>
            <version>Fowler-SR2</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>1.4.0.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

----

=== Zmiana wersji javy

----
<properties>
    <java.version>1.8</java.version>
</properties>
----

=== Użycie pluginu Spring Boot

----
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
----

=== Wyłącznie biblioteki

[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
            <exclusion>
                <groupId>com.fasterxml.jackson.core</groupId>
            </exclusion>
    </exclusions>
</dependency>
----


=== Włączenie nowszej wersji biblioteki


[source,xml]
----
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.4.8</version>
</dependency>

----

=== Uruchamianie

----
mvn spring-boot:run

$ export MAVEN_OPTS=-Xmx1024m -XX:MaxPermSize=128M
----



=== Gradle

** Konfiguracja 

[source,groovy]
----
buildscript {
repositories {
jcenter()
maven { url "http://repo.spring.io/snapshot" }
maven { url "http://repo.spring.io/milestone" }
}
dependencies {
classpath("org.springframework.boot:spring-boot-gradle-plugin:1.3.6.RELEASE")
}
}

apply plugin: 'java'
apply plugin: 'spring-boot'
jar {
   baseName = 'mySimpleApp'
   version = '0.0.1-SNAPSHOT'
}
repositories {
   jcenter()
   ...
}
dependencies {
   compile 'org.springframework.boot:spring-boot-starter' 
   compile("org.springframework.boot:spring-boot-starter-web")
   testCompile("org.springframework.boot:spring-boot-starter-test")
}
----
----
apply plugin: 'java'

repositories {
    jcenter()
}

dependencies {
    compile("org.springframework.boot:spring-boot-starter-web:1.4.0.RELEASE")
}
----

=== spring-boot-gradle-plugin


----
buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.4.0.RELEASE")
    }
}

apply plugin: 'java'
apply plugin: 'spring-boot'

repositories {
    jcenter()
}

dependencies {
    compile("org.springframework.boot:spring-boot-starter-web")
    testCompile("org.springframework.boot:spring-boot-starter-test")
}


----


==== Wyłączanie biblioteki

[source,groovy]
----
compile("org.springframework.boot:spring-boot-starter-web") {
exclude group: 'com.fasterxml.jackson.core'
}
----

==== Włączanie nowszej wersji

----
compile("com.fasterxml.jackson.core:jackson-databind:2.4.8")
----
 
==== Uruchamianie


----
gradle bootRun

export JAVA_OPTS=-Xmx1024m -XX:MaxPermSize=128M
----


=== Java

----
spring run *.java
----


== Uruchamianie jako jar package

$ java -jar target/myproject-0.0.1-SNAPSHOT.jar

$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n -jar target/myproject-0.0.1-SNAPSHOT.jar


include::starters.adoc[]


== @Conditional

== Konfiguracja 

** Spring java config

*** Bean

*** @Configuration

*** @ImportResource

*** @ComponentScan

*** @Import

** Spring annotation

*** @ImportResource

*** @ComponentScan

*** @Import

** Spring profiles

** yaml/properties




** @SpringBootApplication - umożliwia skanowanie komponentów oraz auto-konfigurację




=== Blokowanie wybranej autokonfiguracji

@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})

** Przykład

** @EnableAutoConfiguration(exclude=[ActiveMQAutoConfiguration.class])

To samo co : 

** @SpringBootApplication( exclude={ActiveMQAutoConfiguration.class} )



=== @SpringBootApplication

To samo co : @Configuration + @EnableAutoConfiguration + @ComponentScan


===  Lokalizowanie kandydatów do auto-konfiguracji

Spring Boot sprawdza  plik **META-INF/spring.factories**  w opublikowanych jarach. 
Taki plik powinien zawierać listę klas konfiguracyjnych oznaczonych @EnableAutoConfiguration 

=== XML a  Spring Boot

@ImportResource({"META-INF/services.xml","META-INF/repositories.xml"})

@ImportResource("classpath:applicationContext.xml")


== Hot swapping

** JRebel
 
**  Spring Loaded


== Banner

Podłącznie baneru będzie wykonywane automatycznie gdy plik **banner.txt, banner.gif, banner.jpg czy banner.png** 
znajdą się na classpath lub zostaną jawnie określone przez zmienną  **banner.image.location** 


**${application.version}**  - wesja aplikacji zadeklarowana w MANIFEST.MF 

----
Implementation-Version: 1.0 wyświetli 1.0.
----

**${spring-boot.version}** - wesja Spring Boot użytego w aplikacji

**${application.title}**  - tytył aplikacji zadeklarowany w MANIFEST.MF.

----
Implementation-Title: MyApp wyślietli  MyApp.
---- 
    

NOTE: SpringApplication.setBanner(…​) Generowanie banneru programowalnie. (org.springframework.boot.Banner -> printBanner() method)

spring:
    main:
        banner-mode: "off"
        
        
        
[source,java]
----
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MySpringConfiguration.class);
    app.setBannerMode(Banner.Mode.OFF);
    app.run(args);
}

----
  

=== Fluent builder API

----

new SpringApplicationBuilder()
    .bannerMode(Banner.Mode.OFF)
    .sources(Parent.class)
    .child(Application.class)
    .run(args);
    
----
 
 
 
== Application events and listeners

**ApplicationStartedEvent** - odpalany podczas startu aplikacji, przed procesowaniem z wyjątkiem rejestracji słuchaczy czy initializerów.


**ApplicationEnvironmentPreparedEvent** - kiedy Environment zostanie użyty w kontekscie, ale przed stworzeniem kontekstu   

**ApplicationPreparedEvent** -   wywoływany przed odświeżeniem  aplikacji ale po załadowaniu wszystkich definicji modułów.

**ApplicationReadyEvent** - wywoływany po odświeżeniu lub wywołaniu jakiegokolwiek wywołania zwrotnego które zostało przeprocesowane w aplikacji 

**ApplicationFailedEvent** - wywołany podczas wystąpienie wyjątku na starcie

  
==  Argumenty wywołania


[source,java]
----
@Component
public class MyBean {

    @Autowired
    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption("debug");
        List<String> files = args.getNonOptionArgs();
        // if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
    }

}


----


== Admin features

spring.application.admin.enabled

== Konfigurowanie zewnętrzne

===    @TestPropertySource annotations on your tests.
===    Argumenty z linii poleceń - wywołanie
===    Parametry z SPRING_APPLICATION_JSON 
===    Parametry zawarte w ServletConfig init
===    Parametry zawarte w  ServletContext init
===    Skorzystanie z atrybutów JNDI poprzez java:comp/env.
===    Skorzystanie z Java System properties (System.getProperties()).
===    Skorzystanie z parametrów środowistkowych
===    A RandomValuePropertySource that only has properties in random.*.
===    Profile-specific znajdujące się poza jarem (application-{profile}.properties & YAML)
===    Profile-specific znajdujące się w środku jar (application-{profile}.properties & YAML)
===    Application properties znajdujące się poza  jar (application.properties & YAML)
===    Application properties znajdujące się w środku jar (application.properties & YAML)
===    @PropertySource na @Configuration
===    Domyślne ustawienia poprzez użycie  SpringApplication.setDefaultProperties
    

NOTE: application.properties & application.yml powinni znajdować się na classpath aplikacji

NOTE: Zmienne środowiskowe sprawdzą się podczas praktyki z chmurami.

NOTE: Zawsze możesz użyć command-line

----
data.server=remoteserver:3030
----

=== Zmiana lokacji pliku ustawień i jego nazwy

** /config umieszczony w bieżącym katalogu
** bieżący katalog
** /config w classpath
** classpath


Spring Boot kolejność wyszukiwania pliku z właściwościami to :
** classpath
** classpath:/config
** file:
** file:config/


    
=== Random

----
my.secret=${random.value}
my.number=${random.int}
my.bignumber=${random.long}
my.uuid=${random.uuid}
my.number.less.than.ten=${random.int(10)}
my.number.in.range=${random.int[1024,65536]}
----

=== Placeholders w pliku properties

----
app.name=MyApp
app.description=${app.name} is a Spring Boot application
----


=== YAML

**SnakeYAML** jest ładowany z automatu przez  spring-boot-starter

----
environments:
    dev:
        url: http://dev.bar.com
        name: Developer Setup
    prod:
        url: http://foo.bar.com
        name: My Cool App
----

To samo co : 

----
environments.dev.url=http://dev.bar.com
environments.dev.name=Developer Setup
environments.prod.url=http://foo.bar.com
environments.prod.name=My Cool App

----

----

my:
   servers:
       - dev.bar.com
       - foo.bar.com
       
----


To samo co :

----
my.servers[0]=dev.bar.com
my.servers[1]=foo.bar.com
----


=== ConfigurationProperties

** Przykład

**@ConfigurationProperties(prefix="my")**

=== Type-safe Configuration Properties

----
@ConfigurationProperties(prefix="connection")
public class ConnectionProperties {

    private String username;

    private InetAddress remoteAddress;

    // ... getters and setters

}

----

Zarejestrować :


----
@Configuration
@EnableConfigurationProperties(ConnectionProperties.class)
public class MyConfiguration {
}
----
   

----
@Component
@ConfigurationProperties(prefix="connection")
public class ConnectionProperties {

    // ... getters and setters

}

----

----
# application.yml

connection:
    username: admin
    remoteAddress: 192.168.1.1

# additional configuration as required
----

Użycie: 

[source,java]
----
@Service
public class MyService {

    private final ConnectionProperties connection;

    @Autowired
    public MyService(ConnectionProperties connection) {
        this.connection = connection;
    }

     //...

    @PostConstruct
    public void openConnection() {
        Server server = new Server();
        this.connection.configure(server);
    }

}
----

=== Relaxed binding

----

@ConfigurationProperties(prefix="person")
public class OwnerProperties {

    private String firstName;

    public String getFirstName() {
        return this.firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

}

----

person.firstName camel case
   
person.first-name .properties / .yml
   
person.first_name .properties / .yml
    
PERSON_FIRST_NAME Upper case format. system environment variables


=== @ConfigurationProperties Validation

NOTE: JSR-303 javax.validation 

----
@ConfigurationProperties(prefix="connection")
public class ConnectionProperties {

    @NotNull
    @Valid
    private InetAddress remoteAddress;

    // ... getters and setters

}
----

=== Value

** @Value

=== PropertySource

** @PropertySource

== Profile

** application-{profile}.properties

*** Przykład 

----
application-qa.properties
server.ip=localhost

application-prod.properties
server.ip=http://my-remote.server.com

spring-boot:run -Dspring.profiles.active=prod

----


----
@Configuration
@Profile("production")
public class ProductionConfiguration {

    // ...

}
----

----
spring.profiles.active=dev,hsqldb
----


=== Programowalne ustawianie profilu

**SpringApplication.setAdditionalProfiles(…​)** &   **ConfigurableEnvironment**



== CommandLineRunner

[source,java]
----
public  void run(String...   args){
...
}
----

Zapewnia, że Spring Boot wykona daną metodę tylko raz zaraz po starcie


== ApplicationArguments

== @Enable

== Konfigurowanie

Under the hood, auto-configuration is implemented with standard @Configuration classes. Additional @Conditional annotations are used to constrain when the auto-configuration should apply. Usually auto-configuration classes use @ConditionalOnClass and @ConditionalOnMissingBean annotations. This ensures that auto-configuration only applies when relevant classes are found and when you have not declared your own @Configuration.

You can browse the source code of spring-boot-autoconfigure to see the @Configuration classes that we provide (see the META-INF/spring.factories file).


===  Locating auto-configuration candidates


Spring Boot checks for the presence of a META-INF/spring.factories file within your published jar. The file should list your configuration classes under the EnableAutoConfiguration key.

org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration



You can use the @AutoConfigureAfter or @AutoConfigureBefore annotations if your configuration needs to be applied in a specific order


You almost always want to include one or more @Conditional annotations on your auto-configuration class. The @ConditionalOnMissingBean is one common example that is used to allow developers to ‘override’ auto-configuration if they are not happy with your defaults.

Spring Boot includes a number of @Conditional annotations that you can reuse in your own code by annotating @Configuration classes or individual @Bean methods.


===  Class conditions


The @ConditionalOnClass and @ConditionalOnMissingClass annotations allows configuration to be included based on the presence or absence of specific classes. Due to the fact that annotation metadata is parsed using ASM you can actually use the value attribute to refer to the real class, even though that class might not actually appear on the running application classpath. You can also use the name attribute if you prefer to specify the class name using a String value.

=== Bean conditions

The @ConditionalOnBean and @ConditionalOnMissingBean annotations allow a bean to be included based on the presence or absence of specific beans. You can use the value attribute to specify beans by type, or name to specify beans by name. The search attribute allows you to limit the ApplicationContext hierarchy that should be considered when searching for beans.



=== Property conditions

The @ConditionalOnProperty annotation allows configuration to be included based on a Spring Environment property. Use the prefix and name attributes to specify the property that should be checked. By default any property that exists and is not equal to false will be matched. You can also create more advanced checks using the havingValue and matchIfMissing attributes.


=== Web application conditions

The @ConditionalOnWebApplication and @ConditionalOnNotWebApplication annotations allow configuration to be included depending on whether the application is a 'web application'. A web application is any application that is using a Spring WebApplicationContext, defines a session scope or has a StandardServletEnvironment.

===  SpEL expression conditions

The @ConditionalOnExpression annotation allows configuration to be included based on the result of a SpEL expression.


=== Creating your own starter

A full Spring Boot starter for a library may contain the following components:

    The autoconfigure module that contains the auto-configuration code.
    The starter module that provides a dependency to the autoconfigure module as well as the library and any additional dependencies that are typically useful. In a nutshell, adding the starter should be enough to start using that library.

[Tip]

You may combine the auto-configuration code and the dependency management in a single module if you don’t need to separate those two concerns.



    



== DevTools

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
    </dependency>
</dependencies>
----


[source,groovy]
----
dependencies {
    compile("org.springframework.boot:spring-boot-devtools")
}
----

spring.thymeleaf.cache

During development caching for Thymeleaf, Freemarker, Groovy Templates, Velocity and Mustache are all automatically disabled.

===  LiveReload plugin


Wyłączenie : spring.devtools.livereload.enabled=false.

=== Disabling restart

[source,java]
----
public static void main(String[] args) {
    System.setProperty("spring.devtools.restart.enabled", "false");
    SpringApplication.run(MyApp.class, args);
}
----

=== Remote applications

spring.devtools.remote.secret=mysecret


org.springframework.boot.devtools.RemoteSpringApplication 

== Logowanie


Spring Boot domyślnie używa Commons Logging dla wszystkich wewnętrznych logowań

Domyślna konfiguracja jest dostarczona dla rozwiązań typu : 

** Java Util Logging

**Log4J2

**Logback.


Domyślnie przez użycie 'Staters' Logback będzie użyty do logowania

NOTE: Bardzo dobre rozwiązanie.

NOTE: Połącz Logback z Lombok w celu eliminacji boilerplate code

    Date and Time — Millisecond precision and easily sortable.
    Log Level — ERROR, WARN, INFO, DEBUG or TRACE.
    Process ID.
    A --- separator to distinguish the start of actual log messages.
    Thread name — Enclosed in square brackets (may be truncated for console output).
    Logger name — This is usually the source class name (often abbreviated).
    The log message.
    
NOTE: Logback nie używa poziomu FATAL dla niego odpowiednikiem będzie ERROR 

=== Console

 java -jar myapp.jar --debug
 
 debug=true in your application.properties.
 
 
 --debug
 
 
===  Colorowanie wyjścia 


----
%clr(%5p)

Level   Color

FATAL    Red

ERROR    Red

WARN    Yellow

INFO    Green

DEBUG  Green

TRACE  Green

%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}

    blue
    cyan
    faint
    green
    magenta
    red
    yellow
----
    
=== Pliki z logami

Domyślnie Spring Boot loguje tylko na konsole a nie zapisuje logów do żadnych plików.

NOTE: Jest to słabe rozwiązanie w wielu powodów.


logging.file or logging.path property (for example in your application.properties).


logging.file    logging.path    Example Description

(none)
    

(none)
        

Console only logging.

Specific file
    

(none)
    

my.log
    

Writes to the specified log file. Names can be an exact location or relative to the current directory.

(none)
    

Specific directory
    

/var/log
    

Writes spring.log to the specified directory. Names can be an exact location or relative to the current directory.



=== Poziomy logowania

logging.level.root=WARN
logging.level.org.springframework.web=DEBUG
logging.level.org.hibernate=ERROR


=== Konfiguracja logów użytkownika


** **Logback**
    

logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy

** **Log4j2**
    

log4j2-spring.xml, log4j2.xml

**  **JDK (Java Util Logging)**
    

logging.properties

== WEB

=== Aktualne kontenery

Tomcat 8 3.1 Java 7+

Tomcat 7 3.0 Java 6+

Jetty 9.3 3.1  Java 8+

Jetty 9.2  3.1  Java 7+

Jetty 8 3.0  Java 6+

Undertow 1.3 3.1 Java 7+


=== Spring MVC auto-configuration


** Włączenie ContentNegotiatingViewResolver & BeanViewResolver

** Wsparcie dla sewrowania kontentu statycznego & webjars

** Automatyczna rejestracja kowerterów i formaterów

** Wsparcie dla HttpMessageConvertes

** Automatyczna rejestracja MessageCodesResolver

** Wsparcie dla statycznego index.html

** favicon
 
  
=== Static Content

spring.resources.staticLocations

=== Template engines


    FreeMarker
    Groovy
    Thymeleaf
    Velocity (deprecated in 1.4)
    Mustache
    


== Error Handling    

@ControllerAdvice

@ErrorHandler

@SimpleErrorHandler


             
=== Custom error pages

Od Spring Boot 1.4 wystarczy stworzyć plik o danym kodzie błędu i umieścić do w zasobach statycznych. Automatyczne mapowanie.



== Rest

=== Wywoływanie serwisu REST

----
@Service
public class MyBean {

    private final RestTemplate restTemplate;

    public MyBean(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}
----


=== Dostrojenie RESTTemplate

----
static class ProxyCustomizer implements RestTemplateCustomizer {

    @Override
    public void customize(RestTemplate restTemplate) {
        HttpHost proxy = new HttpHost("proxy.example.com");
        HttpClient httpClient = HttpClientBuilder.create()
                .setRoutePlanner(new DefaultProxyRoutePlanner(proxy) {

                    @Override
                    public HttpHost determineProxy(HttpHost target,
                            HttpRequest request, HttpContext context)
                                    throws HttpException {
                        if (target.getHostName().equals("192.168.0.5")) {
                            return null;
                        }
                        return super.determineProxy(target, request, context);
                    }

                }).build();
        restTemplate.setRequestFactory(
                new HttpComponentsClientHttpRequestFactory(httpClient));
    }

}
----

=== Richardson Maturity Model

source : https://technobeans.wordpress.com/

image:richardson-maturity-model.png[]

== ORM

----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>org.hsqldb</groupId>
    <artifactId>hsqldb</artifactId>
    <scope>runtime</scope>
</dependency>

----

NOTE : spring-jdbc for an embedded database to be auto-configured.

NOTE :. If you’re using H2 you should use DB_CLOSE_ON_EXIT=FALSE 

=== Connection to a production database


    We prefer the Tomcat pooling DataSource for its performance and concurrency, so if that is available we always choose it.
    Otherwise, if HikariCP is available we will use it.
    If neither the Tomcat pooling datasource nor HikariCP are available and if Commons DBCP is available we will use it, but we don’t recommend it in production.
    Lastly, if Commons DBCP2 is available we will use it.
    
    
NOTE: spring-boot-starter-jdbc or spring-boot-starter-data-jpa ‘starters’ you will automatically get a dependency to tomcat-jdbc.


----
spring.datasource.url=jdbc:mysql://localhost/test
spring.datasource.username=dbuser
spring.datasource.password=dbpass
spring.datasource.driver-class-name=com.mysql.jdbc.Driver

----

Default setting

----
# Number of ms to wait before throwing an exception if no connection is available.
spring.datasource.tomcat.max-wait=10000

# Maximum number of active connections that can be allocated from this pool at the same time.
spring.datasource.tomcat.max-active=50

# Validate the connection before borrowing it from the pool.
spring.datasource.tomcat.test-on-borrow=true

----


=== JNDI

----
spring.datasource.jndi-name=java:jboss/datasources/customers
----

=== JdbcTemplate

----
@Component
public class MyBean {

    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public MyBean(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    // ...

}
----

** Tradycyjne podejście 

----
@Bean
public JdbcTemplate jdbcTemplate(DataSource dataSource) {
return new JdbcTemplate(dataSource);
}

@Bean
public DataSource dataSource() {
 return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).addScripts('schema.sql', 'data.sql').build();
}
----

** Podejście Spring Boot

Jeśli Spring Boot wykryje bibiotekę H2 w swoim classpath automatycznie skonfiguruje wbudowanę bazę. Jeśli dodatkowo wykryje JdbcTemplate w swoim classpath skonfiguruje też tę zależność za Ciebie.




=== JPA & Spring Data

    Hibernate — One of the most popular JPA implementations.
    Spring Data JPA — Makes it easy to implement JPA-based repositories.
    Spring ORMs — Core ORM support from the Spring Framework.
    

=== Using H2’s web console


    You are developing a web application
    com.h2database:h2 is on the classpath
    You are using Spring Boot’s developer tools
    
    
spring.h2.console.enabled 

PATH : /h2-console

=== Secure h2-console

    security.user.role
    security.basic.authorize-mode
    security.basic.enabled
   

== NoSql

== MongoDB

Zależność : 

----
spring-boot-starter-data-mongodb             
----

===  MongoTemplate

----
@Component
public class MyBean {

    private final MongoTemplate mongoTemplate;

    @Autowired
    public MyBean(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    // ...

}
----

=== Spring Data MongoDB repositories

----
public interface CityRepository extends Repository<City, Long> {

    Page<City> findAll(Pageable pageable);

    City findByNameAndCountryAllIgnoringCase(String name, String country);

}
----


=== Embedded Mongo

Spring Boot offers auto-configuration for Embedded Mongo. To use it in your Spring Boot application add a dependency on de.flapdoodle.embed:de.flapdoodle.embed.mongo.

The port that Mongo will listen on can be configured using the spring.data.mongodb.port property. To use a randomly allocated free port use a value of zero. The MongoClient created by MongoAutoConfiguration will be automatically configured to use the randomly allocated port.

If you have SLF4J on the classpath, output produced by Mongo will be automatically routed to a logger named org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo.

You can declare your own IMongodConfig and IRuntimeConfig beans to take control of the Mongo instance’s configuration and logging routing.



== Neo4j

=== Connecting to a Neo4j database

Neo4jSession, Session or Neo4jOperations 

=== Neo4jTemplate

----
@Component
public class MyBean {

    private final Neo4jTemplate neo4jTemplate;

    @Autowired
    public MyBean(Neo4jTemplate neo4jTemplate) {
        this.neo4jTemplate = neo4jTemplate;
    }

    // ...

}

----

----
spring.data.neo4j.uri=http://my-server:7474
spring.data.neo4j.username=neo4j
spring.data.neo4j.password=secret
----

=== Using the embedded mode


If you add org.neo4j:neo4j-ogm-embedded-driver to the dependencies of your application, Spring Boot will automatically configure an in-process embedded instance of Neo4j that will not persist any data when your application shuts down. You can explicitly disable that mode using spring.data.neo4j.embedded.enabled=false. You can also enable persistence for the embedded mode:

    spring.data.neo4j.uri=file://var/tmp/graph.db
    

=== Neo4jSession

By default, the lifetime of the session is scope to the application. If you are running a web application you can change it to scope or request easily:

    spring.data.neo4j.session.scope=session
    

===  Spring Data Neo4j repositories

@EnableNeo4jRepositories(basePackages = "com.example.myapp.repository")
@EnableTransactionManagement

----
public interface CityRepository extends GraphRepository<City> {

    Page<City> findAll(Pageable pageable);

    City findByNameAndCountry(String name, String country);

}
----


== Using ResourceBundles for Internationalization (I18N)


== Security


=== @EnableGlobalMethodSecurity

The default AuthenticationManager has a single user (‘user’ username and random password, printed at INFO level when the application starts up)

Using default security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35

== Caching


=== Możliwi dostawcy

    Generic
    JCache (JSR-107)
    EhCache 2.x
    Hazelcast
    Infinispan
    Couchbase
    Redis
    Caffeine
    Guava
    Simple

=== CacheManager

----
@Bean
public CacheManagerCustomizer<ConcurrentMapCacheManager> cacheManagerCustomizer() {
    return new CacheManagerCustomizer<ConcurrentMapCacheManager>() {
        @Override
        public void customize(ConcurrentMapCacheManager cacheManager) {
            cacheManager.setCacheNames(Arrays.asList("one", "two"));
        }
    };
}
----


=== EhCache 2.x

spring.cache.ehcache.config=classpath:config/another-config.xml


=== Guava


If Guava is present, a GuavaCacheManager is auto-configured. Caches can be created on startup using the spring.cache.cache-names property and customized by one of the following (in this order):

    A cache spec defined by spring.cache.guava.spec
    A com.google.common.cache.CacheBuilderSpec bean is defined
    A com.google.common.cache.CacheBuilder bean is defined

For instance, the following configuration creates a foo and bar caches with a maximum size of 500 and a time to live of 10 minutes

spring.cache.cache-names=foo,bar
spring.cache.guava.spec=maximumSize=500,expireAfterAccess=600s

Besides, if a com.google.common.cache.CacheLoader bean is defined, it is automatically associated to the GuavaCacheManager.


== Messaging


=== JMS


=== ActiveMQ support

----
spring-boot-starter-activemq
----


----
spring.activemq.broker-url=tcp://192.168.1.210:9876
spring.activemq.user=admin
spring.activemq.password=secret
----


=== @EnableJms



=== Wysyłanie wiadomości

----
@Component
public class MyBean {

    private final JmsTemplate jmsTemplate;

    @Autowired
    public MyBean(JmsTemplate jmsTemplate) {
        this.jmsTemplate = jmsTemplate;
    }

    // ...

}
----

=== Odbieranie wiadomości

----
@Component
public class MyBean {

    @JmsListener(destination = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}
----


----

If you need to create more JmsListenerContainerFactory instances or if you want to override the default, Spring Boot provides a DefaultJmsListenerContainerFactoryConfigurer that you can use to initialize a DefaultJmsListenerContainerFactory with the same settings as the one that is auto-configured.

For instance, the following exposes another factory that uses a specific MessageConverter:

@Configuration
static class JmsConfiguration {

    @Bean
    public DefaultJmsListenerContainerFactory myFactory(
            DefaultJmsListenerContainerFactoryConfigurer configurer) {
        DefaultJmsListenerContainerFactory factory =
                new DefaultJmsListenerContainerFactory();
        configurer.configure(factory, connectionFactory());
        factory.setMessageConverter(myMessageConverter());
        return factory;
    }

}

Then you can use in any @JmsListener-annotated method as follows:

@Component
public class MyBean {

    @JmsListener(destination = "someQueue", containerFactory="myFactory")
    public void processMessage(String content) {
        // ...
    }

}

----

=== AMQP

----
spring-boot-starter-amqp
----


=== RabbitMQ support

----
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=secret
----

=== Wysyłanie wiadomości

----
@Component
public class MyBean {

    private final AmqpAdmin amqpAdmin;
    private final AmqpTemplate amqpTemplate;

    @Autowired
    public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
        this.amqpAdmin = amqpAdmin;
        this.amqpTemplate = amqpTemplate;
    }

    // ...

}
----

=== Odbieranie wiadomości

----
@Component
public class MyBean {

    @RabbitListener(queues = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}
----


----
If you need to create more RabbitListenerContainerFactory instances or if you want to override the default, Spring Boot provides a SimpleRabbitListenerContainerFactoryConfigurer that you can use to initialize a SimpleRabbitListenerContainerFactory with the same settings as the one that is auto-configured.

For instance, the following exposes another factory that uses a specific MessageConverter:

@Configuration
static class RabbitConfiguration {

    @Bean
    public SimpleRabbitListenerContainerFactory myFactory(
            SimpleRabbitListenerContainerFactoryConfigurer configurer) {
        SimpleRabbitListenerContainerFactory factory =
                new SimpleRabbitListenerContainerFactory();
        configurer.configure(factory, connectionFactory);
        factory.setMessageConverter(myMessageConverter());
        return factory;
    }

}

Then you can use in any @RabbitListener-annotated method as follows:

@Component
public class MyBean {

    @RabbitListener(queues = "someQueue", containerFactory="myFactory")
    public void processMessage(String content) {
        // ...
    }

}
----

== Actuator


What beans have been configured in the Spring application context
What decisions were made by Spring Boot’s auto-configuration
What environment variables, system properties, configuration properties, and
command-line arguments are available to your application
The current state of the threads in and supporting your application
A trace of recent HTTP requests handled by your application
Various metrics pertaining to memory usage, garbage collection, web requests,
and data source usage


** /autoconfig -wyświetla co zostało skonfigurowane automatycznie 

** /beans - wyświetla wszystkie bean'y zarejestrowane w aplikacji

** /configprops - wszystkie konfiguracje properties

** /dump - dump report 

** /env - report o bieżących ustawieniach systemowych

** /health - prosty raport funkcji życiowych aplikacji

----
curl localhost:8090/health      h                                                                                                                                                    
{"status":"UP","diskSpace":{"status":"UP","total":219353915392,"free":127528636416,"threshold":10485760},"mongo":{"status":"UP","version":"2.6.10"}}
----

=== Własny Health endpoint
[source,java]
----
@Component
public class ActiveMQHealth implements HealthIndicator {
private ConnectionFactory factory;
@Autowired
public ActiveMQHealth(ConnectionFactory factory) {
   this.factory = factory;
}
@Override
public Health health() {
    try {
      factory.createConnection();
    } catch (JMSException e) {
      return new Health.Builder().down(e).build();
    }
 return new Health.Builder().status(Status.UP + ": Successfully connected tothe broker").build();
}
}
----

** /info - serwuje informacje o bieżącej konfiguracji aplikacji

** /metrics - metryki dotyczące punktów końcowych, sterty, wątków czy gc 

----
{

    "mem": 1132031,
    "mem.free": 485640,
    "processors": 8,
    "instance.uptime": 1079395,
    "uptime": 1088537,
    "systemload.average": 1.09,
    "heap.committed": 1048576,
    "heap.init": 1048576,
    "heap.used": 561152,
    "heap": 2097152,
    "nonheap.committed": 84928,
    "nonheap.init": 2496,
    "nonheap.used": 83457,
    "nonheap": 0,
    "threads.peak": 42,
    "threads.daemon": 38,
    "threads.totalStarted": 79,
    "threads": 42,
    "classes": 10148,
    "classes.loaded": 10148,
    "classes.unloaded": 0,
    "gc.g1_young_generation.count": 4,
    "gc.g1_young_generation.time": 141,
    "gc.g1_old_generation.count": 0,
    "gc.g1_old_generation.time": 0,
    "gauge.servo.response.health": 8.0,
    "gauge.servo.rest.totaltime": 0.008942816666666667,
    "gauge.servo.rest.count": 0.016666666666666666,
    "gauge.servo.rest.min": 1.155877,
    "gauge.servo.rest.max": 1.155877,
    "gauge.servo.response.api.applications": 3.0,
    "httpsessions.max": -1,
    "httpsessions.active": 0

}
----

** /mappings - wszystkie mapowania URL w aplikacji

** /trace - detale wcześniejszy requestów

----
{

    "timestamp": 1468504478026,
    "info": {
        "method": "POST",
        "path": "/api/applications",
        "headers": {
            "request": {
                "accept": "application/json",
                "content-type": "application/json",
                "user-agent": "Java/1.8.0_91",
                "host": "localhost:8090",
                "connection": "keep-alive",
                "content-length": "273"
            },
            "response": {
                "X-Application-Context": "CEP:dev:8090",
                "Content-Type": "application/json;charset=UTF-8",
                "Transfer-Encoding": "chunked",
                "Date": "Thu, 14 Jul 2016 13:54:38 GMT",
                "status": "201"
            }
        }
    }

},
{

    "timestamp": 1468504468058,
    "info": {
        "method": "GET",
        "path": "/api/journal",
        "headers": {
            "request": {
                "host": "localhost:8090",
                "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:44.0) Gecko/20100101 Firefox/44.0",
                "accept": "text/event-stream",
                "accept-language": "pl,en-US;q=0.7,en;q=0.3",
                "accept-encoding": "gzip, deflate",
                "referer": "http://localhost:8090/index.html",
                "cookie": "__utma=111872281.2131442542.1458644832.1458644832.1461744507.2; __utmz=111872281.1458644832.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _ga=GA1.1.2131442542.1458644832; auth_token=5b97a1d44bf087ab990369e6d6e2d55c413994d4; JSESSIONID=F70300B2C0A464FA47C28817326F8988",
                "connection": "keep-alive",
                "pragma": "no-cache",
                "cache-control": "no-cache"
            },
            "response": {
                "X-Application-Context": "CEP:dev:8090",
                "Content-Type": "text/event-stream;charset=UTF-8",
                "Transfer-Encoding": "chunked",
                "Date": "Thu, 14 Jul 2016 13:54:28 GMT",
                "status": "200"
            }
        }
    }

},...
----

=== Zależność 

spring-boot-actuator

=== remote shell

spring-boot-starter-remote-shell

=== Własne metryki 

** CounterService

[source,java]
----
...
final private CounterService counterService;
counterService.increment("messages.total.book.added");

----

=== Dostrajanie portów

----
management.port=9991
management.address=127.0.0.1
management.context-path=/manage
----

** Tylko JMX

----
management.port=-1
----

== Sending email

If spring.mail.host and the relevant libraries (as defined by spring-boot-starter-mail) are available, a default JavaMailSender is created if none exists. The sender can be further customized by configuration items from the spring.mail namespace, see the MailProperties for more details.

== Spring Session

 Spring Session

Spring Boot provides Spring Session auto-configuration for a wide range of stores:

    JDBC
    MongoDB
    Redis
    Hazelcast
    HashMap

If Spring Session is available, you only need to choose the StoreType that you wish to use to store the sessions. For instance to use JDBC as backend store, you’d configure your application as follows:

spring.session.store-type=jdbc

[Note]

For backward compatibility if Redis is available Spring Session will be automatically configured to use Redis.
[Tip]

You can disable Spring Session by setting the store-type to none.

Each store has specific additional settings. For instance it is possible to customize the name of the table for the jdbc store:

spring.session.jdbc.table-name=SESSIONS



== Monitoring and management over JMX

 By default Spring Boot will create an MBeanServer with bean id ‘mbeanServer’ and expose any of your beans that are annotated with Spring JMX annotations (@ManagedResource, @ManagedAttribute, @ManagedOperation).
 
 
 ==  Testing

est support is provided by two modules; spring-boot-test contains core items, and spring-boot-test-autoconfigure supports auto-configuration for tests.

Most developers will just use the spring-boot-starter-test ‘Starter’ which imports both Spring Boot test modules as well has JUnit, AssertJ, Hamcrest and a number of other useful libraries.


If you use the spring-boot-starter-test ‘Starter’ (in the test scope), you will find the following provided libraries:

    JUnit — The de-facto standard for unit testing Java applications.
    Spring Test & Spring Boot Test — Utilities and integration test support for Spring Boot applications.
    AssertJ — A fluent assertion library.
    Hamcrest — A library of matcher objects (also known as constraints or predicates).
    Mockito — A Java mocking framework.
    JSONassert — An assertion library for JSON.
    JsonPath — XPath for JSON.

Sample

----
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = SprintBootApplication.class)
public class SprintBootApplicationTests {
@Test
public void contextLoads() {
}
}
----



@Test(expected=...)
• @Test(timeout=...)
• @Timed
• @Repeat
• @Ignore
• @ProfileValueSourceConfiguration
• @IfProfileValue


=== Web

----
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = SprintBootWebApplication.class)
@WebAppConfiguration
public class SpringBootWebApplicationTests {
@Test
public void contextLoads() {
}
}
----



strona 119



