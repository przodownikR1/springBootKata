:numbered:
:icons: font
:pagenums:
:imagesdir: images
:iconsdir: ./icons
:stylesdir: ./styles
:scriptsdir: ./js

:image-link: https://pbs.twimg.com/profile_images/425289501980639233/tUWf7KiC.jpeg
ifndef::sourcedir[:sourcedir: ./src/main/java/]
ifndef::resourcedir[:resourcedir: ./src/main/resources/]
ifndef::imgsdir[:imgsdir: ./../images]
:source-highlighter: coderay

== WEB

=== Aktualne kontenery

Tomcat 8 3.1 Java 7+

Tomcat 7 3.0 Java 6+

Jetty 9.3 3.1  Java 8+

Jetty 9.2  3.1  Java 7+

Jetty 8 3.0  Java 6+

Undertow 1.3 3.1 Java 7+


=== Spring MVC auto-configuration


** Włączenie ContentNegotiatingViewResolver & BeanViewResolver

** Wsparcie dla sewrowania kontentu statycznego & webjars

** Automatyczna rejestracja kowerterów i formaterów

** Wsparcie dla HttpMessageConvertes

** Automatyczna rejestracja MessageCodesResolver

** Wsparcie dla statycznego index.html

** favicon
 
  
=== Static Content

spring.resources.staticLocations

=== Template engines


    FreeMarker
    Groovy
    Thymeleaf
    Velocity (deprecated in 1.4)
    Mustache
    

=== favicon


Zasób: 

----
src/main/resource/static/favicon.ico
----


HTML:

[source,html]
----
   <link rel="icon" type="image/x-icon" href="/favicon.ico">
----



== Defiowanie filtrów

----
@Configuration
public class WebConfiguration{
	@Bean
	MyFilter myFilter(){
   	 return	new MyFilter();
	}
}
----

NOTE: Automatyczna detekcja : javax.servlet.Filter


== Interceptory


** HandlerInterceptor

[source,java]
----
public class WebConfiguration extends WebMvcConfigurerAdapter	{  //krok 1

@Bean
LocaleChangeInterceptor localeChangeInterceptor() { //krok 2
		return new LocaleChangeInterceptor();
}

@Override 
public void addInterceptors(InterceptorRegistry registry){ //krok 3
 registry.addInterceptor(localeChangeInterceptor());
}
}
----


Wywołanie : 

----
http://{host}:{port}/{someUrl}?locale={locale_name}
----


== PropertyEditors

[source,java]
----
//tODO
----

Dowiązanie :

----
@InitBinder
public	void initBinder(WebDataBinder binder)	{
  binder.registerCustomEditor(Person.class, new PersonEditor());
}
----

Kontroler :

----
@RequestMapping(value ="/person/{login}", method = RequestMethod.GET)
public Person getPerson(@PathVariable Person person)
{
   return personRepository.findBookByLogin(person.getLogin());
}
----

Wywołanie

----
http://{host}:{port}/person/przodownik
----


WARNING: Nie jest to Thread-safe


== Formatter


----
person Formatter TODO

----


Now	that	we	have	our	formatter,	we	will	add	it	to	the	registry	by	overriding	an
addFormatters(FormatterRegistry	registry) 	method	in	the	 WebConfiguration
class:
@Autowired	
private	BookRepository	bookRepository;


----
@Override
public void addFormatters(FormatterRegistry registry)	{ 
  registry.addFormatter(new PersonFormatter(personRepo));
}
----



----
@RequestMapping(value ="/person/{login}", method = RequestMethod.GET)
public Person getPerson(@PathVariable Person person)
{
   return personRepository.findBookByLogin(person.getLogin());
}
----


== Defiowanie ścieżek do własnych zasobów statycznych


[source,java]
----
@Override
public void addResourceHandlers(ResourceHandlerRegistry	registry){
  registry.addResourceHandler("/resource/**").addResourceLocations("classpath:/");
}
----

** Przykład wywołania

----
http://{host}:{port}/resource/application.properties
----


== Jetty zamiast Tomcat'a

Zależność Gradle : 

----
compile("org.springframework.boot:spring-boot-starter-jetty")

configurations	{
  compile.exclude	module:	"spring-boot-starter-tomcat"
}
----


== Error Handling    

@ControllerAdvice


** Przykład

[source,java]
----
@ControllerAdvice(basePackageClasses = FooController.class)
public class FooControllerAdvice extends ResponseEntityExceptionHandler {

    @ExceptionHandler(YourException.class)
    @ResponseBody
    ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity<>(new CustomErrorType(status.value(), ex.getMessage()), status);
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
        if (statusCode == null) {
            return HttpStatus.INTERNAL_SERVER_ERROR;
        }
        return HttpStatus.valueOf(statusCode);
    }

}

----


@ErrorHandler

** Przykład

[source,java]
----
    @ExceptionHandler({ NotFoundException.class })
    @ResponseStatus(HttpStatus.NOT_FOUND)
    @ResponseBody
    public BadRequest handleException(NotFoundException e, HttpServletRequest request) {
        log(String.format(LOG_RESPONSE_FORMAT, HttpStatus.NOT_FOUND.value(), request.getRequestURI()), e.getMessage());
        return new BadRequest(e.getMessage());
    }


    @ExceptionHandler({ RuntimeException.class })
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ResponseBody
    public BadRequest handleException(RuntimeException e, HttpServletRequest request) {
        log(String.format(LOG_RESPONSE_FORMAT, HttpStatus.INTERNAL_SERVER_ERROR.value(), request.getRequestURI()), e.getMessage());
        return new BadRequest(e.toString());
    }

    @ExceptionHandler({ IllegalArgumentException.class })
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ResponseBody
    public BadRequest handleException(IllegalArgumentException e, HttpServletRequest request) {
        log(String.format(LOG_RESPONSE_FORMAT, HttpStatus.BAD_REQUEST.value(), request.getRequestURI()), e.getMessage());
        return new BadRequest(e.getMessage());
    }


    /**
     *  more informative message than a generic HTTP-400 Bad Request
     */
    @ExceptionHandler(HttpMessageNotReadableException.class)
    @ResponseBody
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public BadRequest handleException(HttpMessageNotReadableException e, HttpServletRequest request) {
        ...
        return new BadRequest(e.getMessage());
}
----


@SimpleErrorHandler


@ResponseStatus

** Przykład

[source,java]
----
@ResponseStatus(value = HttpStatus.BAD_REQUEST)
public class BadRequest extends RuntimeException {
    public BadRequest(String message) {
        super(message);
    }
}

@ResponseStatus(HttpStatus.NOT_FOUND)
public static class NotFound extends RuntimeException {

}
}


----

             
=== Definiowanie stron błędów


NOTE: Od Spring Boot 1.4 wystarczy stworzyć plik o danym kodzie błędu i umieścić do w zasobach statycznych. Automatyczne mapowanie.

** Przykład : 4..

----
src/
 +- main/
     +- java/
     |   + <source code>
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- <other public assets>

----


** Przykład : 5..

----
src/
 +- main/
     +- java/
     |   + <source code>
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.ftl
             +- <other templates>
----


===  ErrorViewResolver [TODO]


** Przykład


[source,java]
----
public class MyErrorViewResolver implements ErrorViewResolver {

    @Override
    public ModelAndView resolveErrorView(HttpServletRequest request,
            HttpStatus status, Map<String, Object> model) {
        // Use the request or status to optionally return a ModelAndView
        return ...
    }

}
----


== Rest

=== Adnotacje 


** @Controller 	

** @RestController

** @ResponseBody 	

** @PathVariable

** Przykład metody kontrolera

[source,java]
----
@RequestMapping("/user/{id}/{field}")
public void showUserField(@PathVariable("id") Long userId, @PathVariable("field") String field) {
...
----


=== Prefix usługi

** Przykład

[source,java]
----
@Controller
@RequestMapping("/user")
public class UserController {
...
}
----

=== Spring Data REST

Zależność : 

----
compile("org.springframework.boot:spring-boot-starter-data-rest")
----


** @RepositoryRestResource - oznaczenie danego repozytiorium

----

@RepositoryRestResource(collectionResourceRel="person",path="persons")

----





=== Wywoływanie serwisu REST

----
@Service
public class MyBean {

    private final RestTemplate restTemplate;

    public MyBean(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}
----


=== Dostrojenie RESTTemplate

----
static class ProxyCustomizer implements RestTemplateCustomizer {

    @Override
    public void customize(RestTemplate restTemplate) {
        HttpHost proxy = new HttpHost("proxy.example.com");
        HttpClient httpClient = HttpClientBuilder.create()
                .setRoutePlanner(new DefaultProxyRoutePlanner(proxy) {

                    @Override
                    public HttpHost determineProxy(HttpHost target,
                            HttpRequest request, HttpContext context)
                                    throws HttpException {
                        if (target.getHostName().equals("192.168.0.5")) {
                            return null;
                        }
                        return super.determineProxy(target, request, context);
                    }

                }).build();
        restTemplate.setRequestFactory(
                new HttpComponentsClientHttpRequestFactory(httpClient));
    }

}
----

=== Richardson Maturity Model

source : https://technobeans.wordpress.com/

image:richardson-maturity-model.png[]



=== Hal browser

Zależność : 

----
compile('org.springframework.data:spring-data-rest-hal-browser')
----

http://{host}:{port}/browser/index.html

=== Swagger 2

Zależności : 

[source,groovy]
----
compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.5.0'
compile group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.5.0'
----


Konfiguracja: 

[source,java]
----
@Configuration
@EnableSwagger2
@Profile("rest")
public class SwaggerConfig extends WebMvcConfigurerAdapter{                                    
    @Bean
    Docket api() { 
        return new Docket(DocumentationType.SWAGGER_2)  
          .select()                                  
          .apis(RequestHandlerSelectors.any())              
          .paths(PathSelectors.ant("/api/**"))          
          .build()
          .apiInfo(apiInfo());                                           
    }
    //TODO get info from properties
    
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
            .title("Boot Kata - Web API")
            .description("Boot Kata based on REST")            
            .license("Apache License Version 2.0")
            .version("1.0")
            .build();
    }
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("swagger-ui.html").addResourceLocations("classpath:/META-INF/resources/");
        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
}
}
----


URL: 

http://{host}:{port}/swagger-ui.html

lub REST

http://{host}:{port}/v2/api-docs/



=== Obsługa wyjątków

** **DefaultHandlerExceptionResolver** 

** **@ControllerAdvice** 
** **@ExceptionHandler** 
** **@ResponseStatus** 


** **ErrorMvcAutoConfiguration** 

ErrorController

${error.path:/error}

${error.whitelabel.enabled:true}


=== Hateoas


==KOPIA !!!!
Media-Type
@RequestMapping(produces, consumes)
Resource
Resources<T>
ResourceAssembler
PagedResourcesAssembler
links
ControllerLinkBuilder
self


==JSON

==Kopia!!
Jackson
JacksonAutoConfiguration
Object Mapper
@Bean c.f.jackson.databind.Module
JacksonProperties
HttpMapperProperties
MappingJackson2HttpMessageConverter
@JsonView


== SSL

=== Generacja klucza 

keytool -genkey -alias springboot -keyalg RSA -keystore src/main/resources/tomcat.keystore


----
@Configuration
public class SecureTomcatConfiguration {
@Bean
public EmbeddedServletContainerFactory servletContainer() throws FileNotFoundException {
TomcatEmbeddedServletContainerFactory f = new TomcatEmbeddedServletContainerFactory();
f.addAdditionalTomcatConnectors(createSslConnector());
return f;
}
private Connector createSslConnector() throws
FileNotFoundException { Connector connector = new Connector(Http11NioProtocol.class.getName());
Http11NioProtocol protocol = (Http11NioProtocol)connector.getProtocolHandler();
connector.setPort(8443);
connector.setSecure(true);
connector.setScheme("https");
protocol.setSSLEnabled(true);
protocol.setKeyAlias("springboot");
protocol.setKeystorePass("password");
protocol.setKeystoreFile(ResourceUtils.getFile("src/main/resources/tomcat.keystore").getAbsolutePath());
protocol.setSslProtocol("TLS");
return connector;
}
}
----




